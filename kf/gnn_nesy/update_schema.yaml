name: Update Schema Row
description: Updates a row in a schema based on a mapping between column names and a JSON object.

inputs:
  - { name: schema_id, type: String, description: "The ID of the schema to update." }
  - { name: update_data_json, type: String, description: "JSON string containing the data to update." }
  - { name: mapping_json, type: String, description: "JSON string mapping column names to keys in update_data_json." }
  - { name: model_id, type: String, description: "The ID of the model to filter by." }
  - { name: bearer_auth_token, type: string, description: "Bearer token for authentication." }
  - { name: domain, type: String, description: "The domain for the API endpoint." }

implementation:
  container:
    image: python:3.9-slim
    command:
      - sh
      - -c
      - |
        pip install requests
        exec "$0" "$@"
      - python3
      - -u
      - -c
      - |
        import json
        import argparse
        import requests

        parser = argparse.ArgumentParser()
        parser.add_argument('--schema_id', type=str, required=True)
        parser.add_argument('--update_data_json', type=str, required=True)
        parser.add_argument('--mapping_json', type=str, required=True)
        parser.add_argument('--model_id', type=str, required=True)
        parser.add_argument('--bearer_auth_token', type=argparse.FileType('r'), required=True)
        parser.add_argument('--domain', type=str, required=True)
        args = parser.parse_args()

        with open(args.bearer_auth_token.name, 'r') as f:
            bearer_auth_token = f.read().strip()
        print(f"{args.update_data_json})
        print(f"{args.mapping_json}")
        update_data = json.loads(args.update_data_json)
        mapping = json.loads(args.mapping_json)

        patch_requests = []
        for column, keys in mapping.items():
            value_to_patch = None
            if isinstance(keys, list):
                # Create a dictionary of the specified keys and their values
                value_to_patch = {key: update_data.get(key) for key in keys if key in update_data}
                # Convert dict to JSON string for the patch value
                value_to_patch = json.dumps(value_to_patch)
            else:
                # Handle single key as before
                if keys in update_data:
                    value_to_patch = str(update_data.get(keys))

            if value_to_patch is not None:
                patch_requests.append({
                    "operation": "REPLACE",
                    "path": column,
                    "value": value_to_patch
                })

        url = f"{args.domain}/pi-entity-instances-service/v2.0/schemas/{args.schema_id}/instances"
        headers = {
            'Content-Type': 'application/json',
            'Authorization': f'Bearer {bearer_auth_token}'
        }

        payload = {
            "dbType": "TIDB",
            "conditionalFilter": {
                "conditions": [
                    {
                        "field": "model_id",
                        "operator": "EQUAL",
                        "value": args.model_id
                    }
                ]
            },
            "partialUpdateRequests": [
                {
                    "patch": patch_requests
                }
            ]
        }

        print(f"Sending PATCH request to {url}")
        print(f"Payload: {json.dumps(payload, indent=2)}")

        try:
            response = requests.patch(url, headers=headers, data=json.dumps(payload))
            response.raise_for_status()
            print("Successfully updated the model instance.")
            print(f"Response: {response.json()}")
        except requests.exceptions.RequestException as e:
            print(f"Error updating model instance: {e}")
            if e.response:
                print(f"Response content: {e.response.text}")
            exit(1)

    args:
      - --schema_id
      - {inputValue: schema_id}
      - --update_data_json
      - {inputValue: update_data_json}
      - --mapping_json
      - {inputValue: mapping_json}
      - --model_id
      - {inputValue: model_id}
      - --bearer_auth_token
      - {inputPath: bearer_auth_token}
      - --domain
      - {inputValue: domain}